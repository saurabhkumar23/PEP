Leaves in Binary Tree - https://practice.geeksforgeeks.org/problems/count-leaves-in-binary-tree/1/
approach - count - 2 calls, left give its count c1 and right give its count c2, If i am a leaf I return c1 + c2 + 1 else c1 + c2. base case - for null return 0.
           print - 2 calls, left will print its leaves, right will print its leaves, If i am a leaf I will print myself. base case - for null return.
           
nodes having exactly one child in Binary Tree - https://www.geeksforgeeks.org/print-the-nodes-having-exactly-one-child-in-a-binary-tree/
approach - count - 2 calls, left give its count c1 and right give its count c2, If i am a single child I return c1 + c2 + 1 else c1 + c2. base case - for null return 0.
           print - 2 calls, left will print its single childs, right will print its single childs, If i am a single child I will print myself. base case - for null return.

number of nodes from a node to root - https://ide.geeksforgeeks.org/tQJONYzU1w
approach - if root value is target return 1, else left will give its count, if there is some count then return count + 1 else call right, if there is some count return 
           count + 1 else return -1. base case - for null return -1.

print k level away from node - https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/
approach - first:
           get ArrayList<TreeNode> node-to-root-path from check-if-data-present-in-a-binary-tree, print (root to node path) method.
           traverse and call print-k-level-down-from-root, print (root to node path) method with k value as k-i and previous node as the blockage node.
           second: (without node-to-root-path arrayList space)
           call number-of-nodes-from-a-node-to-root, and do this modification its code as, whenever you find some count, call print-k-level-down-from-root with k value as
           that returned count and respective node as the blockage node.
           
check if binary tree is bst - https://leetcode.com/problems/validate-binary-search-tree/
approach - left will tell isBst,max,min. If left is not a bst then i am also not a bst, so i will return left.
           right will tell isBst,max,min. If right is not a bst then i am also not a bst, so i will return right.
           if both left and right are bst then i will check myself, if left-max < myself < right-min then i am a bst and my max is right-max and min is left-min, take care 
           of choosing the value of my max and min when dealing with a null bstPair. for that take Math.max() and Math.min()
           base case - for null i will return empty bstPair having isBst as true, max is -infinity and min is +infinity.
           
check if binary tree is balanced - https://leetcode.com/problems/balanced-binary-tree/
approach - left will tell isBal,height. If left is not bal then i am also not bal, so i will return left.
           right will tell isBal,height. If right is not bal then i am also not bal, so i will return right.
           if both left and right are bal then i will check myself, if Math.abs(left-height - right-height) <= 1 then i am bal and my height is 
           Math.max(left-height,right-height) + 1
           base case - for null i will return empty balPair having isBal as true, height as -1.        
           
tilt of a binary tree - https://leetcode.com/problems/binary-tree-tilt/
approach - left will tell its tilt,sum. right will tell its tilt,sum. 
           my tilt will be leftTilt + rightTilt + Math.abs(leftSum - rightSum);
           my sum will leftSum + rightSum + node.data
           base case - for null i will return empty tiltPair having tilt = 0 and sum = 0            
           
diameter of a binary tree - https://leetcode.com/problems/diameter-of-binary-tree/
approach - faith goes like.... left will give its maxDiameter, right will give its maxDiameter, I will calc my maxDiameter as hl + hr + 2, and then return max of all three.
           left will tell its maxDiameter, height. right will tell its maxDiameter, height. 
           my maxDiameter will be max of ld, rd, hl + hr + 2
           my height will max of (hl, hr) + 1
           base case - for null i will return empty diameterPair having maxDiameter = 0 and height = -1   
           
largest BST subtree in a binary tree - https://practice.geeksforgeeks.org/problems/largest-bst/1/
approach - left will tell its isBst, min, max, lBstSize, lBstNode
           right will tell its isBst, min, max, lBstSize, lBstNode
           first i will check myself for bst by basic 3 conditions.
           if i am a bst, then i am the larget bst. 
            myself.isBst = true;
            myself.min = Math.min(left.min, root.data);
            myself.max = Math.max(right.max, root.data);
            myself.lBstSize = left.lBstSize + right.lBstSize + 1;
            myself.lBstNode = root;
           else either left or right is having the largest bst.
            myself.isBst = false;
            myself.lBstSize = left.lBstSize > right.lBstSize ? left.lBstSize : right.lBstSize;
            myself.lBstNode = left.lBstSize > right.lBstSize ? left.lBstNode : right.lBstNode;   
           
lca - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/
approach - all nodes must unique
           it can handle if node1 == node2, for this the answer is that node.
           it can handle for node1 and node2 may be present or not.
           first make two ArrayList and get node-to-root-path from check-if-data-present-in-a-binary-tree, print (root to node path) method.
           if some ArrayList is empty, that signifies that node is not present in tree so we can return null
           if we get both filled ArrayList, traverse both the ArrayList from end simuntaneously and stop till any of them reaches the end or you get unequal data nodes.
           the node just after this index is your answer.
  
Min distance in terms of edges between two given nodes - https://practice.geeksforgeeks.org/problems/min-distance-between-two-given-nodes-of-a-binary-tree/1/
approach - exactly same as above just return i + 1 + j + 1.

are 2 trees similar in structure - https://ide.geeksforgeeks.org/dk8zGXrXu5
approach - I will care only for the current node
           if both null, return true
           if both not null, left will tell me its answer if no i will return no else right will tell me its answer and i will return that as my answer
           if both above conditions not met that means either of them is null, so return false
           
 are 2 trees similar in structure and data - https://practice.geeksforgeeks.org/problems/determine-if-two-trees-are-identical/1/
 approach - exactly same as above, just put one condition in the return statement.
 
 are 2 trees mirror - https://ide.geeksforgeeks.org/vPcXVG7ZeE
 approach - exactly same as above, just call recursively for left with right and vice-versa.
 
 are 2 trees symmetric - https://practice.geeksforgeeks.org/problems/symmetric-tree/1/
 approach - exactly same as above, just call above program with root and root, bcz it will be symmetric if it is mirror of itself.
