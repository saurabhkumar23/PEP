Leaves in Binary Tree - https://practice.geeksforgeeks.org/problems/count-leaves-in-binary-tree/1/
approach - count - 2 calls, left give its count c1 and right give its count c2, If i am a leaf I return c1 + c2 + 1 else c1 + c2. base case - for null return 0.
           print - 2 calls, left will print its leaves, right will print its leaves, If i am a leaf I will print myself. base case - for null return.
           
nodes having exactly one child in Binary Tree - https://www.geeksforgeeks.org/print-the-nodes-having-exactly-one-child-in-a-binary-tree/
approach - count - 2 calls, left give its count c1 and right give its count c2, If i am a single child I return c1 + c2 + 1 else c1 + c2. base case - for null return 0.
           print - 2 calls, left will print its single childs, right will print its single childs, If i am a single child I will print myself. base case - for null return.
           
check if data present in a binary tree - https://ide.geeksforgeeks.org/3aeCUzmujf
approach - check - 2 calls, If am the data then I simply return true else left give your answer, If true I will return true else I will call right, that will be the answer.
                   base case - for null return false.
           print (root to node path) - I will use above recursion tree logic.
                                       2 calls, If am the data then I simply print it and return true else left give your answer, If true I will print it return true else 
                                       I will call right, that will be the final answer, If true i will print it and return that final answer.
                                       base case - for null return false.
           get (root to node path) - 2 calls, If am the data then I simply add myself to arraylist and return my arraylist else left give your answer, If it is having some 
                                     arraylist then there must be some path so I add myself to that arraylist and return that arraylist else I will call right,
                                     that will be the final answer, If it is having some arraylist then there must be some path so I add myself to that arraylist 
                                     and return that arraylist else I will return null.
                                     base case - for null return null.
 
print k level down from root - https://practice.geeksforgeeks.org/problems/k-distance-from-root/1/
approach - if root is at target level, print and return, else call left and right with k - 1, base case - for null return.

number of nodes from a node to root - https://ide.geeksforgeeks.org/tQJONYzU1w
approach - if root value is target return 1, else left will give its count, if there is some count then return count + 1 else call right, if there is some count return 
           count + 1 else return -1. base case - for null return -1.

print k level away from node - https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/
approach - first:
           get ArrayList<TreeNode> node-to-root-path from check-if-data-present-in-a-binary-tree, print (root to node path) method.
           traverse and call print-k-level-down-from-root, print (root to node path) method with k value as k-i and previous node as the blockage node.
           second: (without node-to-root-path arrayList space)
           call number-of-nodes-from-a-node-to-root, and do this modification its code as, whenever you find some count, call print-k-level-down-from-root with k value as
           that returned count and respective node as the blockage node.
           
check if binary tree is bst - https://leetcode.com/problems/validate-binary-search-tree/
approach - left will tell isBst,max,min. If left is not a bst then i am also not a bst, so i will return left.
           right will tell isBst,max,min. If right is not a bst then i am also not a bst, so i will return right.
           if both left and right are bst then i will check myself, if left-max < myself < right-min then i am a bst and my max is right-max and min is left-min, take care 
           of choosing the value of my max and min when dealing with a null bstPair. for that take Math.max() and Math.min()
           base case - for null i will return empty bstPair having isBst as true, max is -infinity and min is +infinity.
           
check if binary tree is balanced - https://leetcode.com/problems/balanced-binary-tree/
approach - left will tell isBal,height. If left is not bal then i am also not bal, so i will return left.
           right will tell isBal,height. If right is not bal then i am also not bal, so i will return right.
           if both left and right are bal then i will check myself, if Math.abs(left-height - right-height) <= 1 then i am bal and my height is 
           Math.max(left-height,right-height) + 1
           base case - for null i will return empty balPair having isBal as true, height as -1.        
           
tilt of a binary tree - https://leetcode.com/problems/binary-tree-tilt/
approach - left will tell its tilt,sum. right will tell its tilt,sum. 
           my tilt will be leftTilt + rightTilt + Math.abs(leftSum - rightSum);
           my sum will leftSum + rightSum + node.data
           base case - for null i will return empty tiltPair having tilt = 0 and sum = 0            
           
diameter of a binary tree - https://leetcode.com/problems/diameter-of-binary-tree/
approach - faith goes like.... left will give its maxDiameter, right will give its maxDiameter, I will calc my maxDiameter as hl + hr + 2, and then return max of all three.
           left will tell its maxDiameter, height. right will tell its maxDiameter, height. 
           my maxDiameter will be max of ld, rd, hl + hr + 2
           my height will max of (hl, hr) + 1
           base case - for null i will return empty diameterPair having maxDiameter = 0 and height = -1   
           
largest BST subtree in a binary tree - https://practice.geeksforgeeks.org/problems/largest-bst/1/
approach - left will tell its isBst, min, max, lBstSize, lBstNode
           right will tell its isBst, min, max, lBstSize, lBstNode
           first i will check myself for bst by basic 3 conditions.
           if i am a bst, then i am the larget bst. 
            myself.isBst = true;
            myself.min = Math.min(left.min, root.data);
            myself.max = Math.max(right.max, root.data);
            myself.lBstSize = left.lBstSize + right.lBstSize + 1;
            myself.lBstNode = root;
           else either left or right is having the largest bst.
            myself.isBst = false;
            myself.lBstSize = left.lBstSize > right.lBstSize ? left.lBstSize : right.lBstSize;
            myself.lBstNode = left.lBstSize > right.lBstSize ? left.lBstNode : right.lBstNode;   
           
           
           
           
           
           
